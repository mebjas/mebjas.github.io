---
layout: compress
---

<!DOCTYPE html>
<html lang="{{ page.lang | default: site.lang | default: "en" }}">

  {% include head.html %}

<script src="https://cdn.tailwindcss.com"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
<style>
    .timeline-container::-webkit-scrollbar {
        height: 8px;
    }
    .timeline-container::-webkit-scrollbar-track {
        background: #f1f1f1;
        border-radius: 10px;
    }
    .timeline-container::-webkit-scrollbar-thumb {
        background: #888;
        border-radius: 10px;
    }
    .timeline-container::-webkit-scrollbar-thumb:hover {
        background: #555;
    }
    .card h3 {
        margin-bottom: 20px;
    }
    
    /* Sync Dialog Styles */
    #syncDialog pre {
        line-height: 1.4;
        color: #374151;
    }
    
    #syncDialog .bg-red-200 {
        background-color: #fecaca;
        border-left: 4px solid #ef4444;
    }
    
    #syncDialog .bg-green-200 {
        background-color: #bbf7d0;
        border-left: 4px solid #10b981;
    }
    
    #syncDialog .bg-yellow-200 {
        background-color: #fef3c7;
        border-left: 4px solid #f59e0b;
    }
</style>

<!-- Enable pre-loading pages with query strings and for external links -->
<body data-instant-allow-query-string data-instant-allow-external-links>

<div class="bg-gray-100 text-gray-800 min-h-screen">

    <div class="w-full p-4 md:p-8 pb-32">
        <!-- Settings Section -->
        <div class="bg-white rounded-lg shadow-lg p-6 mb-8">
            <div id="apiKeyHeader" class="flex justify-between items-center cursor-pointer">
                <div class="flex items-center">
                    <h2 class="text-2xl font-semibold text-gray-800 mr-4">Settings</h2>
                    <!-- Auth Status Indicator -->
                    <div id="authStatusIndicator" class="flex items-center">
                        <svg id="authCardIcon" class="w-5 h-5 text-blue-600 mr-2" fill="currentColor" viewBox="0 0 20 20">
                            <path d="M3 4a1 1 0 011-1h12a1 1 0 011 1v2a1 1 0 01-1 1H4a1 1 0 01-1-1V4zM3 10a1 1 0 011-1h6a1 1 0 011 1v6a1 1 0 01-1 1H4a1 1 0 01-1-1v-6zM14 9a1 1 0 00-1 1v6a1 1 0 001 1h2a1 1 0 001-1v-6a1 1 0 00-1-1h-2z"></path>
                        </svg>
                        <div>
                            <p id="authCardTitle" class="text-sm font-medium text-blue-800">Sign in with Google to backup your data</p>
                            <p id="authCardSubtitle" class="text-xs text-blue-600">Otherwise local storage will be used</p>
                        </div>
                    </div>
                </div>
                <div class="flex items-center space-x-3">
                    <!-- Auth Action -->
                    <div id="authCardAction">
                        <button id="signInButton" class="bg-blue-600 hover:bg-blue-700 text-white font-medium py-2 px-4 rounded-lg transition duration-300 flex items-center text-sm">
                            <svg class="w-4 h-4 mr-2" viewBox="0 0 24 24">
                                <path fill="currentColor" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/>
                                <path fill="currentColor" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/>
                                <path fill="currentColor" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/>
                                <path fill="currentColor" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/>
                            </svg>
                            Sign in
                        </button>
                        <button id="signOutButton" class="hidden bg-red-600 hover:bg-red-700 text-white font-medium py-2 px-3 rounded text-sm transition duration-300">
                            Sign out
                        </button>
                    </div>
                    <!-- Toggle Icon -->
                    <svg id="apiKeyToggleIcon" class="w-6 h-6 transition-transform duration-300" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                </div>
            </div>
            <div id="apiKeyContainer" class="mt-4 space-y-4 hidden">
                <!-- Settings > API key -->
                <p class="text-gray-600">Enter your Google AI Gemini API key to enable natural language processing. Your key is stored locally in your browser and never sent to any server besides Google's.</p>
                <div class="flex flex-col sm:flex-row gap-4">
                    <input type="password" id="apiKeyInput" class="flex-grow w-full px-4 py-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500" placeholder="Enter your Gemini API Key">
                    <button id="saveApiKeyButton" class="w-full sm:w-auto bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg transition duration-300">Save Key</button>
                </div>
                <p id="apiKeyStatus" class="text-sm"></p>
                <!-- Settings > configs -->
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div>
                        <label for="baseCaloriesInput" class="block text-sm font-medium text-gray-700">Base Calories (kcal)</label>
                        <input type="number" id="baseCaloriesInput" class="mt-1 w-full px-3 py-2 border border-gray-300 rounded-lg" value="1500">
                    </div>
                    <div>
                        <label for="calorieDeficitInput" class="block text-sm font-medium text-gray-700">Calorie Deficit (kcal)</label>
                        <input type="number" id="calorieDeficitInput" class="mt-1 w-full px-3 py-2 border border-gray-300 rounded-lg" value="500">
                    </div>
                    <div>
                        <label for="waterTargetInput" class="block text-sm font-medium text-gray-700">Water Target (L)</label>
                        <input type="number" id="waterTargetInput" step="0.1" class="mt-1 w-full px-3 py-2 border border-gray-300 rounded-lg" value="3">
                    </div>
                    <div>
                        <label for="targetWeightInput" class="block text-sm font-medium text-gray-700">Target Weight (kg)</label>
                        <input type="number" id="targetWeightInput" step="0.1" class="mt-1 w-full px-3 py-2 border border-gray-300 rounded-lg" value="78">
                    </div>
                </div>
                <button id="saveTargetsButton" class="w-full sm:w-auto bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg">Save Targets</button>
            </div>
        </div>

        <!-- Floating Input Section (Fixed at Bottom) -->
        <div class="fixed bottom-0 left-0 right-0 z-50 bg-white/95 backdrop-blur-md border-t border-gray-200 p-4 shadow-lg">
            <div class="max-w-4xl mx-auto">
                <div class="relative flex items-center bg-white rounded-full shadow-lg border border-gray-300 focus-within:border-blue-500 focus-within:ring-2 focus-within:ring-blue-500/20 transition-all duration-200">
                    <input 
                        type="text" 
                        id="logInput" 
                        class="flex-1 px-6 py-4 bg-transparent border-none outline-none text-gray-700 placeholder-gray-500 rounded-full text-lg" 
                        placeholder="e.g., '20 pushups', '1 glass of coffee', 'current weight is 84.5kg'"
                    >
                    <button 
                        id="logButton" 
                        class="m-2 bg-blue-600 hover:bg-blue-700 text-white p-3 rounded-full transition-all duration-300 ease-in-out transform hover:scale-105 flex items-center justify-center min-w-[48px] h-12"
                    >
                        <span id="logButtonText" class="sr-only">Send</span>
                        <span id="logButtonIcon" class="block">
                            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8"></path>
                            </svg>
                        </span>
                        <span id="logButtonSpinner" class="hidden">
                            <svg class="animate-spin w-6 h-6 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                                <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                            </svg>
                        </span>
                    </button>
                </div>
            </div>
        </div>

        <!-- Overview section aka "dashboard" -->
        <div class="bg-white rounded-lg shadow-lg p-6 mb-8">
            <h2 class="text-2xl font-semibold mb-4 text-gray-800">Today's Overview</h2>
            <!-- Motivational Quote -->
            <div class="bg-blue-50 border-l-4 border-blue-500 text-blue-700 p-4 mb-6" role="alert">
                <p class="font-bold">Quote of the Day</p>
                <p id="quoteOfTheDay">"The only bad workout is the one that didn't happen."</p>
            </div>

            <!-- Display Cards -->
            <div class="grid grid-cols-1 md:grid-cols-5 gap-4 mb-6">
                <!-- Latest Weight Card -->
                <div class="bg-gray-50 p-4 rounded-lg text-center card relative overflow-hidden">
                    <!-- Background SVG -->
                    <svg class="absolute bottom-0 right-0 w-16 h-16 text-indigo-100 opacity-50" fill="currentColor" viewBox="0 0 24 24">
                        <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/>
                        <circle cx="12" cy="12" r="2"/>
                        <path d="M12 8c-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4-1.79-4-4-4z"/>
                    </svg>
                    <div class="relative z-10">
                        <h3 class="font-semibold text-gray-700">Latest Weight</h3>
                        <p id="latestWeight" class="text-3xl font-bold text-indigo-600">-</p>
                        <p id="latestWeightDate" class="text-sm text-gray-500">Not recorded</p>
                        <p class="text-sm text-indigo-700">Goal: <span id="weightGoal">-</span> kg</p>
                        <div id="weightGoalAnalysis" class="text-xs text-gray-600 mt-2"></div>
                    </div>
                </div>

                <!-- Calories and nutrients Card -->
                <div class="bg-gray-50 p-4 rounded-lg text-center card relative overflow-hidden">
                    <!-- Background SVG -->
                    <svg class="absolute bottom-0 right-0 w-16 h-16 text-green-100 opacity-50" fill="currentColor" viewBox="0 0 24 24">
                        <path d="M9.5 1C8.67 1 8 1.67 8 2.5S8.67 4 9.5 4 11 3.33 11 2.5 10.33 1 9.5 1zm-3 4c-.83 0-1.5.67-1.5 1.5S5.67 8 6.5 8 8 7.33 8 6.5 7.33 5 6.5 5zm7 0c-.83 0-1.5.67-1.5 1.5S12.67 8 13.5 8 15 7.33 15 6.5 14.33 5 13.5 5zm-10 3c-.83 0-1.5.67-1.5 1.5S2.67 11 3.5 11 5 10.33 5 9.5 4.33 8 3.5 8zm13 0c-.83 0-1.5.67-1.5 1.5s.67 1.5 1.5 1.5 1.5-.67 1.5-1.5-.67-1.5-1.5-1.5zm-6.5 1c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm-7 2c-.83 0-1.5.67-1.5 1.5S2.67 14 3.5 14 5 13.33 5 12.5 4.33 11 3.5 11zm13 0c-.83 0-1.5.67-1.5 1.5s.67 1.5 1.5 1.5 1.5-.67 1.5-1.5-.67-1.5-1.5-1.5zm-6.5 3c-.83 0-1.5.67-1.5 1.5S9.67 16 10.5 16s1.5-.67 1.5-1.5-.67-1.5-1.5-1.5zm-3 3c-.83 0-1.5.67-1.5 1.5S6.67 19 7.5 19 9 18.33 9 17.5 8.33 17 7.5 17zm6 0c-.83 0-1.5.67-1.5 1.5s.67 1.5 1.5 1.5 1.5-.67 1.5-1.5-.67-1.5-1.5-1.5z"/>
                    </svg>
                    <div class="relative z-10">
                        <h3 class="font-semibold text-gray-700">Calories & Nutrients</h3>
                        <p id="caloriesRemaining" class="text-3xl font-bold text-green-600">-</p>
                        <p id="caloriesConsumed" class="text-sm text-gray-500">0 consumed</p>
                        <p class="text-sm text-green-700">Goal: <span id="calorieGoal">-</span> kcal</p>
                        <div id="macrosContainer" class="text-xs text-gray-600 mt-2 grid grid-cols-3 gap-1">
                            <div>
                                <p class="font-semibold">Protein</p>
                                <p id="proteinTotal">0g</p>
                            </div>
                            <div>
                                <p class="font-semibold">Carbs</p>
                                <p id="carbsTotal">0g</p>
                            </div>
                            <div>
                                <p class="font-semibold">Fat</p>
                                <p id="fatTotal">0g</p>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Water Card -->
                <div class="bg-gray-50 p-4 rounded-lg text-center card relative overflow-hidden">
                    <!-- Background Water Drop SVG -->
                    <svg class="absolute bottom-0 right-0 w-16 h-16 text-blue-400 opacity-30" fill="currentColor" viewBox="0 0 24 24">
                        <path d="M12 2c-1.1 0-2 .9-2 2 0 1.05.2 2.05.57 3H9c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h6c1.1 0 2-.9 2-2V9c0-1.1-.9-2-2-2h-1.57c.37-.95.57-1.95.57-3 0-1.1-.9-2-2-2z"/>
                        <path d="M12 3c.5 0 1 .2 1.4.6.4.4.6.9.6 1.4 0 .8-.15 1.55-.4 2.25-.25.7-.6 1.35-1 1.95-.4.6-.85 1.15-1.35 1.65-.5.5-1.05.9-1.65 1.25-.6.35-1.25.6-1.95.75-.7.15-1.45.25-2.25.25v-.5c0-.8.15-1.55.4-2.25.25-.7.6-1.35 1-1.95.4-.6.85-1.15 1.35-1.65.5-.5 1.05-.9 1.65-1.25.6-.35 1.25-.6 1.95-.75.15-.7.25-1.45.25-2.25 0-.5-.2-1-.6-1.4C13 3.2 12.5 3 12 3z"/>
                    </svg>
                    <div class="relative z-10 flex flex-col items-center justify-center h-full">
                        <h3 class="font-semibold text-gray-700 mb-2">Water Target</h3>
                        
                        <!-- Circular Progress -->
                        <div class="relative w-20 h-20 mb-2">
                            <svg class="w-20 h-20 transform -rotate-90" viewBox="0 0 100 100">
                                <!-- Background circle -->
                                <circle cx="50" cy="50" r="40" stroke="#e0f2fe" stroke-width="8" fill="none"/>
                                <!-- Progress circle -->
                                <circle 
                                    id="waterProgressCircle" 
                                    cx="50" 
                                    cy="50" 
                                    r="40" 
                                    stroke="#0ea5e9" 
                                    stroke-width="8" 
                                    fill="none"
                                    stroke-linecap="round"
                                    stroke-dasharray="251.2"
                                    stroke-dashoffset="251.2"
                                    class="transition-all duration-500 ease-in-out"
                                />
                            </svg>
                            <!-- Center text -->
                            <div class="absolute inset-0 flex items-center justify-center">
                                <span id="waterConsumedToday" class="text-lg font-bold text-blue-600">0.0L</span>
                            </div>
                        </div>
                        
                        <!-- Water consumption ratio -->
                        <p id="waterProgressRatio" class="text-sm text-gray-500">0.00 / 3.00L</p>
                    </div>
                </div>
                <!-- Exercise Card -->
                <div class="bg-gray-50 p-4 rounded-lg card relative overflow-hidden">
                    <!-- Background SVG -->
                    <svg class="absolute bottom-0 right-0 w-16 h-16 text-orange-100 opacity-50" fill="currentColor" viewBox="0 0 24 24">
                        <path d="M20.5 6c-2.61.7-5.67 1-8.5 1s-5.89-.3-8.5-1L3 9l.5 6L3 18l.5 3h17l.5-3L21 18l-.5-6L21 9l-.5-3z"/>
                        <path d="M2 12h20v2H2z"/>
                        <circle cx="7" cy="12" r="1.5"/>
                        <circle cx="17" cy="12" r="1.5"/>
                        <path d="M9 12h6"/>
                        <path d="M12 8v8"/>
                        <path d="M8 10l8 4"/>
                        <path d="M16 10l-8 4"/>
                    </svg>
                    <div class="relative z-10">
                        <h3 class="font-semibold text-gray-700 mb-2">Exercise</h3>
                        <div id="exerciseTableContainer" class="max-h-32 overflow-y-auto">
                            <table id="exerciseTable" class="w-full text-sm">
                                <thead>
                                    <tr class="border-b border-gray-200">
                                        <th class="text-left py-1 text-gray-600 font-medium">Exercise</th>
                                        <th class="text-right py-1 text-gray-600 font-medium">Reps</th>
                                    </tr>
                                </thead>
                                <tbody id="exerciseTableBody">
                                    <!-- Exercise rows will be injected here -->
                                </tbody>
                            </table>
                            <div id="exerciseEmptyState" class="text-center py-4 text-gray-500">No exercises logged today</div>
                        </div>
                        <p id="exerciseCountSubtitle" class="text-sm text-orange-600 font-medium mb-3">0 exercises today</p>
                    </div>
                </div>
                <!-- Fasting Card -->
                <div class="bg-gray-50 p-4 rounded-lg text-center card relative overflow-hidden">
                    <!-- Background SVG -->
                    <svg class="absolute bottom-0 right-0 w-16 h-16 text-purple-100 opacity-50" fill="currentColor" viewBox="0 0 24 24">
                        <circle cx="12" cy="12" r="10" stroke="currentColor" stroke-width="2" fill="none"/>
                        <path d="M12 6v6l4 2"/>
                        <circle cx="12" cy="12" r="1"/>
                        <path d="M12 2v2"/>
                        <path d="M12 20v2"/>
                        <path d="M4.93 4.93l1.41 1.41"/>
                        <path d="M17.66 17.66l1.41 1.41"/>
                        <path d="M2 12h2"/>
                        <path d="M20 12h2"/>
                        <path d="M6.34 17.66l-1.41 1.41"/>
                        <path d="M19.07 4.93l-1.41 1.41"/>
                    </svg>
                    <div class="relative z-10">
                        <h3 class="font-semibold text-gray-700">Fasting Since</h3>
                        <p id="fastingDuration" class="text-3xl font-bold text-purple-600">-</p>
                        <div id="fastingAnalysis" class="text-xs text-gray-600 mt-2"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Charts Section -->
        <div class="bg-white rounded-lg shadow-lg p-6 mb-8">
            <h2 class="text-2xl font-semibold mb-4 text-gray-800">Data</h2>
            <div class="grid grid-cols-1 gap-8">
                <div class="h-[300px]">
                    <canvas id="weightChart"></canvas>
                </div>
                <div class="h-[300px]">
                    <canvas id="nutritionChart"></canvas>
                </div>
            </div>
        </div>
        
        <!-- Exercise Section -->
        <div class="bg-white rounded-lg shadow-lg p-6 mb-8">
            <h2 class="text-2xl font-semibold mb-4 text-gray-800">Exercise Timeline</h2>
            <div id="exerciseTimelineContainer" class="timeline-container overflow-x-auto whitespace-nowrap py-2">
                <div id="exerciseLog" class="space-x-4">
                    <!-- Exercise cards will be injected here -->
                </div>
            </div>
        </div>

        <!-- Logs and Errors Section -->
        <div class="bg-white rounded-lg shadow-lg p-6 mb-8">
             <div id="logHeader" class="flex justify-between items-center cursor-pointer">
                <h2 class="text-2xl font-semibold text-gray-800">Audit Log</h2>
                <svg id="logToggleIcon" class="w-6 h-6 transition-transform duration-300" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
            </div>
            <div id="logContainer" class="mt-4 space-y-4 hidden">
                <!-- Log entries will be injected here -->
            </div>
        </div>

        <div id="errorContainer" class="hidden bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded-lg relative mb-4" role="alert">
            <strong class="font-bold">Error!</strong>
            <span class="block sm:inline" id="errorMessage"></span>
            <span class="absolute top-0 bottom-0 right-0 px-4 py-3">
                <svg onclick="dismissError()" class="fill-current h-6 w-6 text-red-500" role="button" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><title>Close</title><path d="M14.348 14.849a1.2 1.2 0 0 1-1.697 0L10 11.818l-2.651 3.031a1.2 1.2 0 1 1-1.697-1.697l2.758-3.15-2.759-3.152a1.2 1.2 0 1 1 1.697-1.697L10 8.183l2.651-3.031a1.2 1.2 0 1 1 1.697 1.697l-2.758 3.152 2.758 3.15a1.2 1.2 0 0 1 0 1.698z"/></svg>
            </span>
        </div>

        <!-- Data Sync Confirmation Dialog -->
        <div id="syncDialog" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
            <div class="bg-white rounded-lg p-6 max-w-6xl w-full max-h-[90vh] overflow-hidden flex flex-col">
                <h3 class="text-xl font-semibold mb-4">Data Sync Conflict</h3>
                <p class="text-gray-600 mb-4">You have different data locally and in the cloud. Review the differences below:</p>
                
                <!-- Data Comparison -->
                <div class="flex-1 overflow-auto mb-6">
                    <div class="grid grid-cols-2 gap-4 h-full">
                        <!-- Local Data -->
                        <div class="flex flex-col">
                            <div class="flex items-center justify-between mb-2">
                                <div class="flex items-center">
                                    <div class="w-4 h-4 bg-red-500 rounded mr-2"></div>
                                    <h4 class="font-semibold text-gray-800">Local Data (<span id="localDataCount">0</span> entries)</h4>
                                </div>
                            </div>
                            <div class="flex-1 overflow-auto bg-gray-50 p-3 rounded border">
                                <pre id="localDataJson" class="text-xs font-mono whitespace-pre-wrap"></pre>
                            </div>
                        </div>
                        
                        <!-- Cloud Data -->
                        <div class="flex flex-col">
                            <div class="flex items-center justify-between mb-2">
                                <div class="flex items-center">
                                    <div class="w-4 h-4 bg-green-500 rounded mr-2"></div>
                                    <h4 class="font-semibold text-gray-800">Cloud Data (<span id="cloudDataCount">0</span> entries)</h4>
                                </div>
                            </div>
                            <div class="flex-1 overflow-auto bg-gray-50 p-3 rounded border">
                                <pre id="cloudDataJson" class="text-xs font-mono whitespace-pre-wrap"></pre>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Action Buttons -->
                <div class="flex justify-between items-center">
                    <div class="text-sm text-gray-500">
                        <span class="inline-block w-3 h-3 bg-red-200 rounded mr-1"></span>Local only
                        <span class="inline-block w-3 h-3 bg-green-200 rounded mr-1 ml-3"></span>Cloud only
                        <span class="inline-block w-3 h-3 bg-yellow-200 rounded mr-1 ml-3"></span>Different
                    </div>
                    <div class="flex space-x-4">
                        <button id="syncDialogCancel" class="px-4 py-2 text-gray-600 hover:text-gray-800 transition">Keep Local</button>
                        <button id="syncDialogReplace" class="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 transition">Use Cloud Data</button>
                    </div>
                </div>
            </div>
        </div>

        <div style="margin-bottom: 100px;"></div>
        
    </div>
    <script type="module">
    // Import the functions you need from the SDKs you need
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.10.0/firebase-app.js";
    import { getAnalytics } from "https://www.gstatic.com/firebasejs/11.10.0/firebase-analytics.js";
    import { getAuth, GoogleAuthProvider, signInWithPopup, signOut, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.10.0/firebase-auth.js";
    import { getFirestore, collection, doc, getDoc, setDoc, onSnapshot } from "https://www.gstatic.com/firebasejs/11.10.0/firebase-firestore.js";
    // TODO: Add SDKs for Firebase products that you want to use
    // https://firebase.google.com/docs/web/setup#available-libraries

    // Your web app's Firebase configuration
    // For Firebase JS SDK v7.20.0 and later, measurementId is optional
    const firebaseConfig = {
        apiKey: "AIzaSyDB0AAJ1BNg9U1A8wpmTxRU5PzNjEIAyxo",
        authDomain: "minhazav-dev-fitness-tracker.firebaseapp.com",
        projectId: "minhazav-dev-fitness-tracker",
        storageBucket: "minhazav-dev-fitness-tracker.firebasestorage.app",
        messagingSenderId: "431839137376",
        appId: "1:431839137376:web:9f365ddfd2e56f46763d05",
        measurementId: "G-PYPP1DYR3Q"
    };

    // Initialize Firebase
    const app = initializeApp(firebaseConfig);
    const analytics = getAnalytics(app);
    const auth = getAuth(app);
    const db = getFirestore(app);
    const provider = new GoogleAuthProvider();
    
    // Make Firebase objects globally accessible
    window.auth = auth;
    window.db = db;
    window.provider = provider;
    window.signInWithPopup = signInWithPopup;
    window.signOut = signOut;
    window.onAuthStateChanged = onAuthStateChanged;
    window.doc = doc;
    window.getDoc = getDoc;
    window.setDoc = setDoc;
    </script>
    <script type="module">//
        // --- DOM Elements ---
        const logInput = document.getElementById('logInput');
        const logButton = document.getElementById('logButton');
        const logButtonText = document.getElementById('logButtonText');
        const logButtonIcon = document.getElementById('logButtonIcon');
        const logButtonSpinner = document.getElementById('logButtonSpinner');
        const logContainer = document.getElementById('logContainer');
        const logHeader = document.getElementById('logHeader');
        const logToggleIcon = document.getElementById('logToggleIcon');
        const errorContainer = document.getElementById('errorContainer');
        const errorMessage = document.getElementById('errorMessage');
        const exerciseLog = document.getElementById('exerciseLog');
        const exerciseTimelineContainer = document.getElementById('exerciseTimelineContainer');

        // --- Authentication Elements ---
        const authCardIcon = document.getElementById('authCardIcon');
        const authCardTitle = document.getElementById('authCardTitle');
        const authCardSubtitle = document.getElementById('authCardSubtitle');
        const signInButton = document.getElementById('signInButton');
        const signOutButton = document.getElementById('signOutButton');

        // --- Gemini API Key Elements ---
        const apiKeyHeader = document.getElementById('apiKeyHeader');
        const apiKeyToggleIcon = document.getElementById('apiKeyToggleIcon');
        const apiKeyContainer = document.getElementById('apiKeyContainer');
        const apiKeyInput = document.getElementById('apiKeyInput');
        const saveApiKeyButton = document.getElementById('saveApiKeyButton');
        const apiKeyStatus = document.getElementById('apiKeyStatus');

        // --- Dashboard Elements ---
        const quoteOfTheDay = document.getElementById('quoteOfTheDay');
        const caloriesRemaining = document.getElementById('caloriesRemaining');
        const calorieGoal = document.getElementById('calorieGoal');
        const caloriesConsumed = document.getElementById('caloriesConsumed');
        const waterProgress = document.getElementById('waterProgress');
        const waterProgressCircle = document.getElementById('waterProgressCircle');
        const waterConsumedToday = document.getElementById('waterConsumedToday');
        const waterProgressRatio = document.getElementById('waterProgressRatio');
        const waterGoal = document.getElementById('waterGoal');
        const exerciseCountSubtitle = document.getElementById('exerciseCountSubtitle');
        const exerciseTableBody = document.getElementById('exerciseTableBody');
        const exerciseTable = document.getElementById('exerciseTable');
        const exerciseEmptyState = document.getElementById('exerciseEmptyState');
        const latestWeight = document.getElementById('latestWeight');
        const latestWeightDate = document.getElementById('latestWeightDate');
        const weightGoal = document.getElementById('weightGoal');
        const weightGoalAnalysis = document.getElementById('weightGoalAnalysis');
        const proteinTotal = document.getElementById('proteinTotal');
        const carbsTotal = document.getElementById('carbsTotal');
        const fatTotal = document.getElementById('fatTotal');
        const targetsContainer = document.getElementById('targetsContainer');
        const baseCaloriesInput = document.getElementById('baseCaloriesInput');
        const calorieDeficitInput = document.getElementById('calorieDeficitInput');
        const waterTargetInput = document.getElementById('waterTargetInput');
        const targetWeightInput = document.getElementById('targetWeightInput');
        const saveTargetsButton = document.getElementById('saveTargetsButton');
        const fastingDuration = document.getElementById('fastingDuration');
        const fastingAnalysis = document.getElementById('fastingAnalysis');

        // --- Dialog Elements ---
        const syncDialog = document.getElementById('syncDialog');
        const syncDialogCancel = document.getElementById('syncDialogCancel');
        const syncDialogReplace = document.getElementById('syncDialogReplace');
        const localDataJson = document.getElementById('localDataJson');
        const cloudDataJson = document.getElementById('cloudDataJson');
        const localDataCount = document.getElementById('localDataCount');
        const cloudDataCount = document.getElementById('cloudDataCount');

        // --- Chart Instances ---
        let weightChart, nutritionChart;

        // --- Data Store ---
        let allData = []; // This will be populated from localStorage or cloud
        let currentUser = null; // Current authenticated user

        // --- Local Storage Database ---
        const STORAGE_KEY = 'health-log-data';
        const GEMINI_API_KEY = 'gemini-api-key';
        const TARGETS_KEY = 'health-log-targets';
        const QUOTE_KEY = 'health-log-quote';
        const WEIGHT_ANALYSIS_KEY = 'health-log-weight-analysis';
        const FASTING_ANALYSIS_KEY = 'health-log-fasting-analysis';
        
        // Initialize local storage and load existing data
        function initializeLocalDB() {
            try {
                const storedData = localStorage.getItem(STORAGE_KEY);
                if (storedData) {
                    allData = JSON.parse(storedData);
                    console.log("Loaded existing data from localStorage:", allData.length, "entries");
                } else {
                    allData = [];
                    console.log("No existing data found, starting fresh");
                }
                // Sort data by timestamp after loading
                allData.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
                renderAll();
            } catch (e) {
                console.error("Failed to load data from localStorage:", e);
                showError("Failed to load existing data. Starting fresh.");
                allData = [];
                renderAll();
            }
        }

        // Initialize API Key UI
        function initializeApiKeyUI() {
            const savedKey = localStorage.getItem(GEMINI_API_KEY);
            if (savedKey) {
                apiKeyStatus.textContent = "API Key is saved. You can update it here.";
                apiKeyStatus.className = "text-sm text-green-600";
                apiKeyInput.placeholder = "••••••••••••••••••••••••••••••";
            } else {
                apiKeyStatus.textContent = "API Key not set. Please enter your key to use the app.";
                apiKeyStatus.className = "text-sm text-red-600";
            }
        }

        // Initialize Targets UI
        function initializeTargetsUI() {
            const targets = getTargets();
            baseCaloriesInput.value = targets.baseCalories;
            calorieDeficitInput.value = targets.calorieDeficit;
            waterTargetInput.value = targets.waterTarget;
            targetWeightInput.value = targets.targetWeight;
        }

        // Initialize the app
        initializeLocalDB();
        initializeApiKeyUI();
        initializeTargetsUI();
        fetchAndDisplayQuote();
        
        // Initialize authentication
        window.onAuthStateChanged(window.auth, (user) => {
            currentUser = user;
            updateAuthUI();
            if (user) {
                console.log("User is signed in:", user.email);
                syncData();
            } else {
                console.log("User is signed out");
            }
        });

        
        // Save data to localStorage
        function saveToLocalStorage() {
            try {
                localStorage.setItem(STORAGE_KEY, JSON.stringify(allData));
                console.log("Data saved to localStorage:", allData.length, "entries");
            } catch (e) {
                console.error("Failed to save data to localStorage:", e);
                showError("Failed to save data locally.");
            }
        }

        // --- Cloud Backup Functions ---
        
        // Save data to Firestore
        async function saveToCloud() {
            if (!currentUser) return;
            
            try {
                const userDocRef = window.doc(window.db, 'userData', currentUser.uid);
                const apiKey = localStorage.getItem(GEMINI_API_KEY);
                
                await window.setDoc(userDocRef, {
                    data: allData,
                    lastUpdated: new Date().toISOString(),
                    userEmail: currentUser.email,
                    apiKey: apiKey || null
                });
                console.log("Data saved to cloud:", allData.length, "entries");
            } catch (e) {
                console.error("Failed to save data to cloud:", e);
                showError("Failed to backup data to cloud.");
            }
        }

        // Save API key to Firestore
        async function saveApiKeyToCloud(apiKey) {
            if (!currentUser) return;
            
            try {
                const userDocRef = window.doc(window.db, 'userData', currentUser.uid);
                const docSnap = await window.getDoc(userDocRef);
                
                const existingData = docSnap.exists() ? docSnap.data() : {};
                
                await window.setDoc(userDocRef, {
                    ...existingData,
                    apiKey: apiKey || null,
                    lastUpdated: new Date().toISOString()
                });
                console.log("API key saved to cloud");
            } catch (e) {
                console.error("Failed to save API key to cloud:", e);
                showError("Failed to backup API key to cloud.");
            }
        }

        // Load data from Firestore
        async function loadFromCloud() {
            if (!currentUser) return null;
            
            try {
                const userDocRef = window.doc(window.db, 'userData', currentUser.uid);
                const docSnap = await window.getDoc(userDocRef);
                
                if (docSnap.exists()) {
                    const cloudData = docSnap.data();
                    console.log("Loaded data from cloud:", cloudData.data?.length || 0, "entries");
                    
                    // Handle API key sync
                    if (cloudData.apiKey) {
                        const localApiKey = localStorage.getItem(GEMINI_API_KEY);
                        if (localApiKey !== cloudData.apiKey && cloudData.apiKey != null && cloudData.apiKey != undefined && cloudData.apiKey.trim() != "") {
                            console.log("Cloud API key differs from local, using cloud version");
                            localStorage.setItem(GEMINI_API_KEY, cloudData.apiKey);
                            initializeApiKeyUI();
                        }
                    }
                    
                    return cloudData.data || [];
                } else {
                    console.log("No cloud data found");
                    return [];
                }
            } catch (e) {
                console.error("Failed to load data from cloud:", e);
                showError("Failed to load data from cloud.");
                return null;
            }
        }

        // Deep equality check for arrays of objects
        function deepEqual(arr1, arr2) {
            if (arr1.length !== arr2.length) return false;
            
            // Sort both arrays by timestamp and id for consistent comparison
            const sorted1 = [...arr1].sort((a, b) => {
                const timeCompare = new Date(a.timestamp) - new Date(b.timestamp);
                return timeCompare !== 0 ? timeCompare : a.id.localeCompare(b.id);
            });
            
            const sorted2 = [...arr2].sort((a, b) => {
                const timeCompare = new Date(a.timestamp) - new Date(b.timestamp);
                return timeCompare !== 0 ? timeCompare : a.id.localeCompare(b.id);
            });
            
            // Compare each entry
            for (let i = 0; i < sorted1.length; i++) {
                if (!objectsEqual(sorted1[i], sorted2[i])) {
                    return false;
                }
            }
            return true;
        }

        // Deep equality check for objects
        function objectsEqual(obj1, obj2) {
            const keys1 = Object.keys(obj1);
            const keys2 = Object.keys(obj2);
            
            if (keys1.length !== keys2.length) return false;
            
            for (let key of keys1) {
                if (!keys2.includes(key)) return false;
                
                const val1 = obj1[key];
                const val2 = obj2[key];
                
                if (typeof val1 === 'object' && val1 !== null && typeof val2 === 'object' && val2 !== null) {
                    if (!objectsEqual(val1, val2)) return false;
                } else if (val1 !== val2) {
                    return false;
                }
            }
            return true;
        }

        // Sync data between local and cloud
        async function syncData() {
            if (!currentUser) return;
            
            const cloudData = await loadFromCloud();
            if (cloudData === null) return;
            
            const hasLocalData = allData.length > 0;
            const hasCloudData = cloudData.length > 0;
            
            if (!hasLocalData && hasCloudData) {
                // No local data, use cloud data
                allData = cloudData;
                allData.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
                saveToLocalStorage();
                renderAll();
                console.log("Synced cloud data to local");
            } else if (hasLocalData && !hasCloudData) {
                // No cloud data, upload local data and API key
                await saveToCloud();
                console.log("Synced local data to cloud");
            } else if (hasLocalData && hasCloudData) {
                // Both have data, check if they're different using deep equality
                if (!deepEqual(allData, cloudData)) {
                    // Data is different, show dialog
                    showSyncDialog(cloudData);
                } else {
                    console.log("Local and cloud data are in sync");
                }
            } else {
                // No data on either side, but sync API key if available locally
                const localApiKey = localStorage.getItem(GEMINI_API_KEY);
                if (localApiKey) {
                    await saveApiKeyToCloud(localApiKey);
                    console.log("Synced local API key to cloud");
                }
            }


        }

        // Show sync confirmation dialog
        function showSyncDialog(cloudData) {
            syncDialog.classList.remove('hidden');
            
            // Store cloud data temporarily for the dialog
            syncDialog.cloudData = cloudData;
            
            // Update data counts
            localDataCount.textContent = allData.length;
            cloudDataCount.textContent = cloudData.length;
            
            // Update the description with timestamp information
            updateSyncDialogDescription(allData, cloudData);
            
            // Determine and show which dataset is more recent
            updateDatasetRecencyIndicators(allData, cloudData);
            
            // Format and display the data with highlighting
            displayDataComparison(allData, cloudData);
        }

        // Update sync dialog description with timestamp information
        function updateSyncDialogDescription(localData, cloudData) {
            const localLatest = getLatestTimestamp(localData);
            const cloudLatest = getLatestTimestamp(cloudData);
            const descriptionEl = document.querySelector('#syncDialog p');
            
            let description = "You have different data locally and in the cloud. Review the differences below:";
            
            if (localLatest && cloudLatest) {
                const localDate = new Date(localLatest).toLocaleString();
                const cloudDate = new Date(cloudLatest).toLocaleString();
                
                if (localLatest > cloudLatest) {
                    description += ` Your local data is more recent (${localDate} vs ${cloudDate}).`;
                } else if (cloudLatest > localLatest) {
                    description += ` Your cloud data is more recent (${cloudDate} vs ${localDate}).`;
                } else {
                    description += ` Both datasets have the same latest timestamp (${localDate}).`;
                }
            }
            
            descriptionEl.textContent = description;
        }

        // Update indicators to show which dataset has more recent data
        function updateDatasetRecencyIndicators(localData, cloudData) {
            const localLatest = getLatestTimestamp(localData);
            const cloudLatest = getLatestTimestamp(cloudData);
            
            // Get the header elements
            const localHeaderContainer = document.querySelector('#syncDialog .grid > div:first-child .flex');
            const cloudHeaderContainer = document.querySelector('#syncDialog .grid > div:last-child .flex');
            
            // Remove any existing "Latest" badges
            const existingLocalBadge = localHeaderContainer.querySelector('.latest-badge');
            const existingCloudBadge = cloudHeaderContainer.querySelector('.latest-badge');
            if (existingLocalBadge) existingLocalBadge.remove();
            if (existingCloudBadge) existingCloudBadge.remove();
            
            // Add "Latest" indicator to the more recent dataset
            if (localLatest && cloudLatest) {
                const latestBadge = '<span class="latest-badge ml-2 px-2 py-1 bg-blue-500 text-white text-xs rounded font-semibold">Latest</span>';
                
                if (localLatest > cloudLatest) {
                    localHeaderContainer.innerHTML += latestBadge;
                } else if (cloudLatest > localLatest) {
                    cloudHeaderContainer.innerHTML += latestBadge;
                }
                // If timestamps are equal, don't show any indicator
            }
        }

        // Get the latest timestamp from a dataset
        function getLatestTimestamp(data) {
            if (!data || data.length === 0) return null;
            
            return data.reduce((latest, entry) => {
                const entryTime = new Date(entry.timestamp).getTime();
                return entryTime > latest ? entryTime : latest;
            }, 0);
        }

        // Display data comparison with highlighting
        function displayDataComparison(localData, cloudData) {
            const localFormatted = formatDataForComparison(localData);
            const cloudFormatted = formatDataForComparison(cloudData);
            
            // Create maps for easier comparison
            const localMap = new Map(localData.map(item => [item.id, item]));
            const cloudMap = new Map(cloudData.map(item => [item.id, item]));
            
            // Highlight differences
            localDataJson.innerHTML = highlightDifferences(localFormatted, localMap, cloudMap, 'local');
            cloudDataJson.innerHTML = highlightDifferences(cloudFormatted, cloudMap, localMap, 'cloud');
        }

        // Format data for better readability
        function formatDataForComparison(data) {
            return data.map(entry => ({
                id: entry.id,
                timestamp: new Date(entry.timestamp).toLocaleString(),
                category: entry.category,
                data: entry.data,
                originalText: entry.originalText
            }));
        }

        // Highlight differences between datasets
        function highlightDifferences(formattedData, thisMap, otherMap, side) {
            let html = '';
            
            formattedData.forEach((entry, index) => {
                const otherEntry = otherMap.get(entry.id);
                let entryClass = '';
                
                if (!otherEntry) {
                    // Entry exists only in this dataset
                    entryClass = side === 'local' ? 'bg-red-200' : 'bg-green-200';
                } else {
                    // Entry exists in both, check if different
                    const thisEntryStr = JSON.stringify(thisMap.get(entry.id));
                    const otherEntryStr = JSON.stringify(otherEntry);
                    if (thisEntryStr !== otherEntryStr) {
                        entryClass = 'bg-yellow-200';
                    }
                }
                
                const entryJson = JSON.stringify(entry, null, 2);
                html += `<div class="${entryClass} p-2 mb-2 rounded">${escapeHtml(entryJson)}</div>`;
            });
            
            return html || '<div class="text-gray-500 italic">No data</div>';
        }

        // Escape HTML to prevent XSS
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Hide sync dialog
        function hideSyncDialog() {
            syncDialog.classList.add('hidden');
            delete syncDialog.cloudData;
            
            // Clear the displayed data
            localDataJson.innerHTML = '';
            cloudDataJson.innerHTML = '';
            localDataCount.textContent = '0';
            cloudDataCount.textContent = '0';
            
            // Reset description text
            const descriptionEl = document.querySelector('#syncDialog p');
            descriptionEl.textContent = "You have different data locally and in the cloud. Review the differences below:";
            
            // Remove any latest badges
            const localBadge = document.querySelector('#syncDialog .grid > div:first-child .latest-badge');
            const cloudBadge = document.querySelector('#syncDialog .grid > div:last-child .latest-badge');
            if (localBadge) localBadge.remove();
            if (cloudBadge) cloudBadge.remove();
        }

        // Replace local data with cloud data
        async function replaceLocalWithCloud() {
            if (syncDialog.cloudData) {
                allData = syncDialog.cloudData;
                allData.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
                saveToLocalStorage();
                renderAll();
                console.log("Replaced local data with cloud data");
            }
            hideSyncDialog();
        }

        // Combined save function
        async function saveData() {
            saveToLocalStorage();
            if (currentUser) {
                await saveToCloud();
            }
        }

        // Authentication functions
        async function signInWithGoogle() {
            try {
                const result = await window.signInWithPopup(window.auth, window.provider);
                currentUser = result.user;
                console.log("Signed in:", currentUser.email);
                updateAuthUI();
                await syncData();
            } catch (error) {
                console.error("Sign in failed:", error);
                showError("Failed to sign in with Google.");
            }
        }

        async function signOutUser() {
            try {
                await window.signOut(window.auth);
                currentUser = null;
                console.log("Signed out");
                updateAuthUI();
            } catch (error) {
                console.error("Sign out failed:", error);
                showError("Failed to sign out.");
            }
        }

        // Update authentication UI
        function updateAuthUI() {
            if (currentUser) {
                // Signed in - show user email and sign out button
                authCardIcon.classList.remove('text-blue-600');
                authCardIcon.classList.add('text-green-600');
                authCardTitle.textContent = `Signed in as ${currentUser.email}`;
                authCardTitle.classList.remove('text-blue-800');
                authCardTitle.classList.add('text-green-700');
                authCardSubtitle.textContent = "Data is backed up to cloud";
                authCardSubtitle.classList.remove('text-blue-600');
                authCardSubtitle.classList.add('text-green-600');
                signInButton.classList.add('hidden');
                signOutButton.classList.remove('hidden');
            } else {
                // Signed out - show sign in prompt and button
                authCardIcon.classList.remove('text-green-600');
                authCardIcon.classList.add('text-blue-600');
                authCardTitle.textContent = "Sign in with Google to backup your data";
                authCardTitle.classList.remove('text-green-700');
                authCardTitle.classList.add('text-blue-800');
                authCardSubtitle.textContent = "Otherwise local storage will be used";
                authCardSubtitle.classList.remove('text-green-600');
                authCardSubtitle.classList.add('text-blue-600');
                signInButton.classList.remove('hidden');
                signOutButton.classList.add('hidden');
            }
        }

        // --- Targets Logic ---
        function getTargets() {
            const storedTargets = localStorage.getItem(TARGETS_KEY);
            const defaults = {
                baseCalories: 1500,
                calorieDeficit: 500,
                waterTarget: 3,
                targetWeight: 78
            };
            return storedTargets ? JSON.parse(storedTargets) : defaults;
        }

        function saveTargets() {
            console.log("saveTargets called");
            const targets = {
                baseCalories: parseInt(baseCaloriesInput.value) || 1500,
                calorieDeficit: parseInt(calorieDeficitInput.value) || 500,
                waterTarget: parseFloat(waterTargetInput.value) || 3,
                targetWeight: parseFloat(targetWeightInput.value) || 78
            };
            console.log("targets", targets);
            localStorage.setItem(TARGETS_KEY, JSON.stringify(targets));
            renderAll();
        }

        // --- Quote of the Day Logic ---
        async function fetchAndDisplayQuote() {
            const today = new Date().toISOString().split('T')[0];
            const storedQuote = JSON.parse(localStorage.getItem(QUOTE_KEY));

            if (storedQuote && storedQuote.date === today) {
                quoteOfTheDay.textContent = storedQuote.quote;
                return;
            }

            quoteOfTheDay.textContent = "Generating a fresh quote for you...";
            try {
                const quote = await getMotivationalQuote();
                localStorage.setItem(QUOTE_KEY, JSON.stringify({ date: today, quote: quote }));
                quoteOfTheDay.textContent = quote;
            } catch (error) {
                console.error("Failed to fetch quote:", error);
                quoteOfTheDay.textContent = "The only bad workout is the one that didn't happen."; // Fallback
            }
        }

        async function getMotivationalQuote() {
            const apiKey = localStorage.getItem(GEMINI_API_KEY);
            if (!apiKey) {
                throw new Error("API key not set");
            }
            const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${apiKey}`;
            const prompt = "Generate a short, motivational quote about fitness or health. Make it inspiring and concise.";

            const response = await fetch(API_URL, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] })
            });

            if (!response.ok) {
                throw new Error("Failed to fetch quote from API");
            }
            const data = await response.json();
            return data.candidates[0].content.parts[0].text.trim();
        }

        async function getWeightGoalAnalysis(currentWeight, targetWeight) {
            const apiKey = localStorage.getItem(GEMINI_API_KEY);
            if (!apiKey) {
                console.warn("API key not set, skipping weight goal analysis.");
                return null;
            }

            const weightDifference = currentWeight - targetWeight;
            if (Math.abs(weightDifference) < 0.1) {
                return { analysis: "You've reached your target weight! Great job!" };
            }

            const prompt = `My current weight is ${currentWeight} kg and my target is ${targetWeight} kg. Calculate the total calorie deficit or surplus needed to reach my target, assuming 1kg of weight is roughly 7700 calories. Then, provide a very short motivational statement (under 15 words). Respond with a minified JSON object with two keys: "calories" (integer) and "motivation" (string). Example: {"calories": 7700, "motivation": "You're on the right track, keep going!"}`;

            const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${apiKey}`;

            try {
                const response = await fetch(API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: [{ parts: [{ text: prompt }] }],
                        generationConfig: {
                            response_mime_type: "application/json",
                        }
                    })
                });

                if (!response.ok) {
                    throw new Error("Failed to fetch weight analysis from API");
                }
                const data = await response.json();
                return JSON.parse(data.candidates[0].content.parts[0].text);
            } catch (error) {
                console.error("Error fetching weight goal analysis:", error);
                return null; // Fail gracefully
            }
        }

        async function getFastingAnalysis(hours) {
            const apiKey = localStorage.getItem(GEMINI_API_KEY);
            if (!apiKey) {
                console.warn("API key not set, skipping fasting analysis.");
                return null;
            }

            if (hours < 12) {
                return { analysis: "Not in a significant fasting state yet." };
            }

            const prompt = `I have been fasting for ${hours.toFixed(1)} hours. Provide a very short (under 20 words) summary of what this means for my body and how it might align with health goals like weight loss or metabolic health. Respond with a minified JSON object with one key: "analysis" (string). Example: {"analysis": "Your body is likely entering ketosis, burning fat for fuel. Great for weight loss."}`;

            const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${apiKey}`;

            try {
                const response = await fetch(API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: [{ parts: [{ text: prompt }] }],
                        generationConfig: {
                            response_mime_type: "application/json",
                        }
                    })
                });

                if (!response.ok) {
                    throw new Error("Failed to fetch fasting analysis from API");
                }
                const data = await response.json();
                return JSON.parse(data.candidates[0].content.parts[0].text);
            } catch (error) {
                console.error("Error fetching fasting analysis:", error);
                return null; // Fail gracefully
            }
        }


        // Generate unique ID for entries
        function generateId() {
            return Date.now().toString(36) + Math.random().toString(36).substr(2);
        }
        
        /**
         * Calls the Gemini API to categorize natural language input.
         * @param {string} text - The user's input text.
         * @returns {Promise<object>} - A promise that resolves with the structured data.
         */
        async function getStructuredData(text) {
            const apiKey = localStorage.getItem(GEMINI_API_KEY);
            if (!apiKey) {
                showError("Gemini API key not set. Please configure it first by clicking 'Configure Gemini API'.");
                throw new Error("API key not set");
            }

            const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${apiKey}`;
            
            const prompt = `
                Analyze the following user input and extract structured health data. The current date is ${new Date().toDateString()}.
                The user input is: "${text}"

                Respond with a minified list of JSON object with two keys: "category" and "data". If a single entry has more than one categories, split the result into individual JSON objects in the list with different categories.

                Possible categories are: "weight", "water", "food", "exercise", or "unknown".

                - For "weight", the "data" object should have a "value" key with the weight in kg (float).
                - For "water", the "data" object should have an "amount" key with the volume in Liters (float). Assume "a glass" is 0.25L.
                - For "food", the "data" object should have "item" (string) and "calories" (integer) keys. Provide a reasonable calorie estimate. Also include "protein" (integer, in grams), "carbs" (integer, in grams), "fat" (integer, in grams). Also add a "thoughts" key (string, under 15 words) with your opinion on the food for weight loss, LDL & HDL control, and muscle gain. Also include a boolean key "breaks_fast". A food is considered to break a fast if it has more than 15 calories.
                - For "exercise", the "data" object should have "type" (string) and either "reps" (integer) or "duration_minutes" (integer).
                - If the input is ambiguous or cannot be categorized, the category should be "unknown" and data should be an empty object.

                Example 1:
                Input: "My current weight is 84.5kg"
                Output: [{"category":"weight","data":{"value":84.5}}]

                Example 2:
                Input: "I drank 2 glasses of water"
                Output: [{"category":"water","data":{"amount":0.5}}]

                Example 3:
                Input: "I drank 1 glass of coffee"
                Output: [{"category":"water","data":{"amount":0.25}}, {"category":"food","data":{"item":"coffee","calories":5,"protein":0,"carbs":1,"fat":0,"thoughts":"Negligible impact. Fine in moderation.","breaks_fast":false}}]

                Example 4:
                Input: "Ate a slice of pepperoni pizza"
                Output: [{"category":"food","data":{"item":"pepperoni pizza slice","calories":285,"protein":12,"carbs":30,"fat":12,"thoughts":"High in calories and fat. Not ideal for weight loss or heart health.","breaks_fast":true}}]

                Example 5:
                Input: "Did 20 pushups and ran for 15 minutes"
                Output: [{"category":"exercise","data":{"type":"pushups and running","reps":20,"duration_minutes":15}}]
            `;

            try {
                const response = await fetch(API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: [{ parts: [{ text: prompt }] }],
                        generationConfig: {
                            response_mime_type: "application/json",
                        }
                    })
                });

                if (!response.ok) {
                    const errorBody = await response.json();
                    console.error("Gemini API Error:", errorBody);
                    throw new Error(`API Error: ${errorBody.error.message}`);
                }

                const responseData = await response.json();
                const jsonString = responseData.candidates[0].content.parts[0].text;
                return JSON.parse(jsonString);

            } catch (error) {
                console.error("Error calling Gemini API:", error);
                showError(`Failed to process via Gemini: ${error.message}. Check your API key and network.`);
                throw error;
            }
        }

        /**
         * Saves a new entry to local storage and cloud.
         * @param {object} entry - The data entry to log.
         */
        async function logData(entry) {
            try {
                // Add unique ID to entry
                entry.id = generateId();
                
                // Add to local data array
                allData.push(entry);
                
                // Sort data by timestamp
                allData.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
                
                // If a new weight is logged, clear the analysis cache
                if (entry.category === 'weight') {
                    localStorage.removeItem(WEIGHT_ANALYSIS_KEY);
                }

                if (entry.category === 'food') {
                    localStorage.removeItem(FASTING_ANALYSIS_KEY);
                }

                // Save to localStorage and cloud
                await saveData();
                
                // Re-render the UI
                renderAll();
                
                console.log("Entry saved:", entry);
            } catch (error) {
                console.error("Error saving entry:", error);
                showError("Failed to save the entry.");
            }
        }

        /**
         * Deletes an entry from local storage and cloud.
         * @param {string} id - The ID of the entry to delete.
         */
        window.deleteEntry = async function(id) {
            try {
                // Remove from local data array
                const index = allData.findIndex(entry => entry.id === id);
                if (index !== -1) {
                    allData.splice(index, 1);
                    
                    // Save to localStorage and cloud
                    await saveData();
                    
                    // Re-render the UI
                    renderAll();
                    
                    console.log("Entry deleted:", id);
                } else {
                    console.warn("Entry not found for deletion:", id);
                }
            } catch (error) {
                console.error("Error deleting entry:", error);
                showError("Failed to delete the entry.");
            }
        }

        function renderAll() {
            logContainer.innerHTML = '';
            exerciseLog.innerHTML = '';
            
            allData.forEach(renderLogEntry);
            updateDashboard();
            renderCharts();
            renderExerciseTimeline();
        }
        
        function updateDashboard() {
            const targets = getTargets();
            const today = new Date().toLocaleDateString();

            const todaysFood = allData.filter(d => d.category === 'food' && new Date(d.timestamp).toLocaleDateString() === today);
            const todaysWater = allData.filter(d => d.category === 'water' && new Date(d.timestamp).toLocaleDateString() === today);
            const todaysExercise = allData.filter(d => d.category === 'exercise' && new Date(d.timestamp).toLocaleDateString() === today);

            const caloriesConsumedValue = todaysFood.reduce((sum, curr) => sum + (curr.data.calories || 0), 0);
            const proteinToday = todaysFood.reduce((sum, curr) => sum + (curr.data.protein || 0), 0);
            const carbsToday = todaysFood.reduce((sum, curr) => sum + (curr.data.carbs || 0), 0);
            const fatToday = todaysFood.reduce((sum, curr) => sum + (curr.data.fat || 0), 0);
            const waterDrankToday = todaysWater.reduce((sum, curr) => sum + (curr.data.amount || 0), 0);
            
            const totalCalorieGoal = targets.baseCalories - targets.calorieDeficit;
            const remainingCals = totalCalorieGoal - caloriesConsumedValue;

            // Update UI
            calorieGoal.textContent = totalCalorieGoal;
            caloriesConsumed.textContent = `${caloriesConsumedValue} kcal consumed`;
            caloriesRemaining.textContent = remainingCals;
            
            // Update water progress with circular indicator
            const waterPercentage = Math.min((waterDrankToday / targets.waterTarget) * 100, 100);
            const circumference = 2 * Math.PI * 40; // radius = 40
            const offset = circumference - (waterPercentage / 100) * circumference;
            
            waterConsumedToday.textContent = `${waterDrankToday.toFixed(1)}L`;
            waterProgressRatio.textContent = `${waterDrankToday.toFixed(2)} / ${targets.waterTarget.toFixed(2)}L`;
            waterProgressCircle.style.strokeDashoffset = offset;
            
            // Update exercise table
            if (todaysExercise.length > 0) {
                // Create exercise map to sum up duplicates
                const exerciseMap = {};
                todaysExercise.forEach(ex => {
                    const exerciseType = ex.data.type;
                    if (!exerciseMap[exerciseType]) {
                        exerciseMap[exerciseType] = {
                            reps: 0,
                            duration: 0,
                            hasReps: false,
                            hasDuration: false
                        };
                    }
                    if (ex.data.reps) {
                        exerciseMap[exerciseType].reps += ex.data.reps;
                        exerciseMap[exerciseType].hasReps = true;
                    }
                    if (ex.data.duration_minutes) {
                        exerciseMap[exerciseType].duration += ex.data.duration_minutes;
                        exerciseMap[exerciseType].hasDuration = true;
                    }
                });

                // Update subtitle
                const exerciseCount = Object.keys(exerciseMap).length;
                exerciseCountSubtitle.textContent = `${exerciseCount} exercise${exerciseCount !== 1 ? 's' : ''} today`;

                // Generate table rows
                let tableRowsHTML = '';
                Object.entries(exerciseMap).forEach(([exerciseType, data]) => {
                    let valueText = '';
                    if (data.hasReps && data.hasDuration) {
                        valueText = `${data.reps} reps, ${data.duration}min`;
                    } else if (data.hasReps) {
                        valueText = `${data.reps}`;
                    } else if (data.hasDuration) {
                        valueText = `${data.duration}min`;
                    } else {
                        valueText = '-';
                    }
                    
                    tableRowsHTML += `
                        <tr class="border-b border-gray-100 last:border-b-0">
                            <td class="py-1 text-left text-gray-700">${exerciseType}</td>
                            <td class="py-1 text-right text-gray-600">${valueText}</td>
                        </tr>
                    `;
                });

                exerciseTableBody.innerHTML = tableRowsHTML;
                exerciseTable.style.display = 'table';
                exerciseEmptyState.style.display = 'none';
            } else {
                exerciseCountSubtitle.textContent = '0 exercises today';
                exerciseTableBody.innerHTML = '';
                exerciseTable.style.display = 'none';
                exerciseEmptyState.style.display = 'block';
            }

            weightGoal.textContent = targets.targetWeight;
            proteinTotal.textContent = `${proteinToday}g`;
            carbsTotal.textContent = `${carbsToday}g`;
            fatTotal.textContent = `${fatToday}g`;

            // Update latest weight
            const weightEntries = allData.filter(d => d.category === 'weight');
            if (weightEntries.length > 0) {
                const lastWeightEntry = weightEntries[weightEntries.length - 1];
                latestWeight.textContent = `${lastWeightEntry.data.value} kg`;
                latestWeightDate.textContent = `on ${new Date(lastWeightEntry.timestamp).toLocaleDateString()}`;
                updateWeightGoalAnalysis(lastWeightEntry.data.value, targets.targetWeight);
            } else {
                latestWeight.textContent = '-';
                latestWeightDate.textContent = 'Not recorded';
                weightGoalAnalysis.innerHTML = '';
            }
            updateFastingDashboard();
        }

        async function updateWeightGoalAnalysis(currentWeight, targetWeight) {
            if (!targetWeight || !currentWeight) {
                weightGoalAnalysis.innerHTML = '';
                return;
            }

            const cachedAnalysis = JSON.parse(localStorage.getItem(WEIGHT_ANALYSIS_KEY));
            if (cachedAnalysis && cachedAnalysis.currentWeight === currentWeight) {
                const { analysis } = cachedAnalysis;
                weightGoalAnalysis.innerHTML = `<p class="italic">"${analysis.motivation}"</p><p>~${analysis.calories.toLocaleString()} kcal to go.</p>`;
                return;
            }

            weightGoalAnalysis.innerHTML = `<p class="text-gray-500">Analyzing...</p>`;
            const analysis = await getWeightGoalAnalysis(currentWeight, targetWeight);

            if (analysis) {
                localStorage.setItem(WEIGHT_ANALYSIS_KEY, JSON.stringify({ currentWeight, analysis }));
                weightGoalAnalysis.innerHTML = `<p class="italic">"${analysis.motivation}"</p><p>~${analysis.calories.toLocaleString()} kcal to go.</p>`;
            } else {
                weightGoalAnalysis.innerHTML = '';
            }
        }

        async function updateFastingDashboard() {
            const foodEntries = allData.filter(d => d.category === 'food').sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
            let lastFastBreakingMealTime = null;

            for (const entry of foodEntries) {
                const breaksFast = entry.data.breaks_fast === undefined 
                    ? (entry.data.calories || 0) > 15 
                    : entry.data.breaks_fast;
                
                if (breaksFast) {
                    lastFastBreakingMealTime = new Date(entry.timestamp);
                    break;
                }
            }

            if (lastFastBreakingMealTime) {
                const now = new Date();
                const hours = (now - lastFastBreakingMealTime) / (1000 * 60 * 60);
                fastingDuration.textContent = `${hours.toFixed(1)}h`;
                updateFastingAnalysis(hours);
            } else {
                fastingDuration.textContent = 'N/A';
                fastingAnalysis.innerHTML = 'No fast-breaking meals logged yet.';
            }
        }

        async function updateFastingAnalysis(hours) {
            if (hours < 1) {
                fastingAnalysis.innerHTML = '';
                return;
            }
            const cachedAnalysis = JSON.parse(localStorage.getItem(FASTING_ANALYSIS_KEY));
            // Use a tolerance for cached hours to avoid re-fetching for minor changes
            if (cachedAnalysis && Math.abs(cachedAnalysis.hours - hours) < 0.5) {
                fastingAnalysis.innerHTML = `<p class="italic">"${cachedAnalysis.analysis.analysis}"</p>`;
                return;
            }

            fastingAnalysis.innerHTML = `<p class="text-gray-500">Analyzing...</p>`;
            const analysis = await getFastingAnalysis(hours);

            if (analysis) {
                localStorage.setItem(FASTING_ANALYSIS_KEY, JSON.stringify({ hours, analysis }));
                fastingAnalysis.innerHTML = `<p class="italic">"${analysis.analysis}"</p>`;
            } else {
                fastingAnalysis.innerHTML = '';
            }
        }
        
        function renderLogEntry(entry) {
            const logElement = document.createElement('div');
            logElement.className = 'bg-gray-50 p-3 rounded-lg shadow-sm flex justify-between items-center';
            let content = `<div class="flex items-center">`;
            const date = new Date(entry.timestamp).toLocaleString();
            switch (entry.category) {
                case 'weight': content += `<span class="text-xl mr-3">⚖️</span> <div><p class="font-semibold">Weight Logged: ${entry.data.value} kg</p><p class="text-sm text-gray-500">${date}</p></div>`; break;
                case 'water': content += `<span class="text-xl mr-3">💧</span> <div><p class="font-semibold">Water Intake: ${entry.data.amount} L</p><p class="text-sm text-gray-500">${date}</p></div>`; break;
                case 'food': 
                    content += `<span class="text-xl mr-3">🍎</span> <div><p class="font-semibold">Food: ${entry.data.item}</p><p class="text-gray-600 text-sm">Calories: ~${entry.data.calories} kcal</p>`;
                    if (entry.data.thoughts) {
                        content += `<p class="text-gray-600 text-sm italic">"${entry.data.thoughts}"</p>`;
                    }
                    content += `<p class="text-sm text-gray-500">${date}</p></div>`; 
                    break;
                case 'exercise': content += `<span class="text-xl mr-3">🏋️</span> <div><p class="font-semibold">Exercise: ${entry.data.type}</p><p class="text-gray-600 text-sm">${entry.data.reps ? `Reps: ${entry.data.reps}` : `Duration: ${entry.data.duration_minutes} min`}</p><p class="text-sm text-gray-500">${date}</p></div>`; break;
            }
            content += `</div>`;
            const deleteButton = `<button onclick="deleteEntry('${entry.id}')" class="text-red-500 hover:text-red-700 font-semibold text-sm">Delete</button>`;
            logElement.innerHTML = content + deleteButton;
            logContainer.prepend(logElement);
        }

        function renderExerciseTimeline() {
            const allExercises = allData.filter(e => e.category === 'exercise');
            if (allExercises.length === 0) {
                exerciseLog.innerHTML = '<p class="text-gray-500 text-center w-full">No exercises logged yet.</p>';
                return;
            }
            const exerciseGroups = allExercises.reduce((acc, curr) => {
                const date = new Date(curr.timestamp).toLocaleDateString();
                if (!acc[date]) acc[date] = [];
                acc[date].push(curr.data);
                return acc;
            }, {});
            Object.keys(exerciseGroups).sort((a,b) => new Date(a) - new Date(b)).forEach(date => {
                const card = document.createElement('div');
                card.className = 'inline-block bg-gray-50 p-4 rounded-lg w-[180px] h-full align-top whitespace-normal shadow';
                let exercisesHtml = `<h3 class="font-bold mb-2 text-gray-700">${date}</h3><ul class="text-sm space-y-1">`;
                exerciseGroups[date].forEach(ex => {
                    exercisesHtml += `<li><span class="font-semibold">${ex.type}:</span> ${ex.reps ? `${ex.reps} reps` : `${ex.duration_minutes} min`}</li>`;
                });
                exercisesHtml += '</ul>';
                card.innerHTML = exercisesHtml;
                exerciseLog.appendChild(card);
            });
            exerciseTimelineContainer.scrollLeft = exerciseTimelineContainer.scrollWidth;
        }

        function renderCharts() {
            const labels = [...new Set(allData.map(d => new Date(d.timestamp).toLocaleDateString()))].sort((a,b) => new Date(a) - new Date(b));
            const weightData = {
                labels: labels,
                datasets: [{
                    label: 'Weight (kg)',
                    data: labels.map(label => {
                        const dayData = allData.filter(d => new Date(d.timestamp).toLocaleDateString() === label && d.category === 'weight');
                        return dayData.length > 0 ? dayData[dayData.length - 1].data.value : null;
                    }),
                    borderColor: 'rgba(239, 68, 68, 1)', backgroundColor: 'rgba(239, 68, 68, 0.2)', type: 'line', fill: false, tension: 0.1, spanGaps: true
                }]
            };
            const nutritionData = {
                labels: labels,
                datasets: [
                {
                    label: 'Calories (kcal)',
                    data: labels.map(label => {
                        const dayData = allData.filter(d => new Date(d.timestamp).toLocaleDateString() === label && d.category === 'food');
                        return dayData.reduce((sum, curr) => sum + (curr.data.calories || 0), 0);
                    }),
                    backgroundColor: 'rgba(34, 197, 94, 0.6)',
                    borderColor: 'rgba(34, 197, 94, 1)',
                    borderWidth: 1,
                },
                {
                    label: 'Water (L)',
                    data: labels.map(label => {
                        const dayData = allData.filter(d => new Date(d.timestamp).toLocaleDateString() === label && d.category === 'water');
                        return dayData.reduce((sum, curr) => sum + (curr.data.amount || 0), 0);
                    }),
                    backgroundColor: 'rgba(107, 114, 128, 0.6)',
                    borderColor: 'rgba(107, 114, 128, 1)',
                    borderWidth: 1,
                },
                {
                    label: 'Protein (g)',
                    data: labels.map(label => {
                        const dayData = allData.filter(d => new Date(d.timestamp).toLocaleDateString() === label && d.category === 'food');
                        return dayData.reduce((sum, curr) => sum + (curr.data.protein || 0), 0);
                    }),
                    backgroundColor: 'rgba(239, 68, 68, 0.6)',
                    borderColor: 'rgba(239, 68, 68, 1)',
                    borderWidth: 1,
                    yAxisID: 'yGrams',
                },
                {
                    label: 'Carbs (g)',
                    data: labels.map(label => {
                        const dayData = allData.filter(d => new Date(d.timestamp).toLocaleDateString() === label && d.category === 'food');
                        return dayData.reduce((sum, curr) => sum + (curr.data.carbs || 0), 0);
                    }),
                    backgroundColor: 'rgba(59, 130, 246, 0.6)',
                    borderColor: 'rgba(59, 130, 246, 1)',
                    borderWidth: 1,
                    yAxisID: 'yGrams',
                },
                {
                    label: 'Fat (g)',
                    data: labels.map(label => {
                        const dayData = allData.filter(d => new Date(d.timestamp).toLocaleDateString() === label && d.category === 'food');
                        return dayData.reduce((sum, curr) => sum + (curr.data.fat || 0), 0);
                    }),
                    backgroundColor: 'rgba(245, 158, 11, 0.6)',
                    borderColor: 'rgba(245, 158, 11, 1)',
                    borderWidth: 1,
                    yAxisID: 'yGrams',
                }
            ]
            };
            if (weightChart) weightChart.destroy();
            weightChart = new Chart(document.getElementById('weightChart'), { type: 'line', data: weightData, options: { responsive: true, maintainAspectRatio: false, plugins: { title: { display: true, text: 'Weight Trend' } }, scales: { y: { beginAtZero: false } } } });
            if (nutritionChart) nutritionChart.destroy();
            nutritionChart = new Chart(document.getElementById('nutritionChart'), { type: 'bar', data: nutritionData, options: { responsive: true, maintainAspectRatio: false, plugins: { title: { display: true, text: 'Nutrition Overview (Macros)' } }, scales: { x: { stacked: false }, y: { stacked: false, beginAtZero: true, title: { display: true, text: 'Grams' } } } } });
        }

        function showError(message) {
            errorMessage.textContent = message;
            errorContainer.classList.remove('hidden');
        }
        window.dismissError = function() { errorContainer.classList.add('hidden'); }
        
        function toggleLoading(isLoading) {
            logButton.disabled = isLoading;
            logButtonIcon.classList.toggle('hidden', isLoading);
            logButtonSpinner.classList.toggle('hidden', !isLoading);
        }

        // --- Event Listeners ---
        logButton.addEventListener('click', async () => {
            const text = logInput.value.trim();
            if (!text) return;
            toggleLoading(true);
            dismissError();
            try {
                const results = await getStructuredData(text);
                if (!Array.isArray(results) || results.length === 0) {
                    showError("No valid data extracted. Please try again.");
                    toggleLoading(false);
                    return;
                }
                results.forEach(async result => {
                    if (results.category === 'unknown') {
                        showError("Sorry, I couldn't understand that. Please try phrasing it differently.");
                        return;
                    } 
                    const newEntry = {
                            timestamp: new Date().toISOString(),
                            originalText: text,
                            ...result
                        };
                    await logData(newEntry);
                    logInput.value = '';
                });
            } catch (error) {
                console.error("Error processing input:", error);
                showError("An unexpected error occurred. Please try again.");
            } finally {
                toggleLoading(false);
            }
        });

        logInput.addEventListener('keypress', (event) => { if (event.key === 'Enter') logButton.click(); });
        logHeader.addEventListener('click', () => {
            logContainer.classList.toggle('hidden');
            logToggleIcon.classList.toggle('rotate-180');
        });

        apiKeyHeader.addEventListener('click', () => {
            apiKeyContainer.classList.toggle('hidden');
            apiKeyToggleIcon.classList.toggle('rotate-180');
        });

        saveApiKeyButton.addEventListener('click', async () => {
            const key = apiKeyInput.value.trim();
            if (key) {
                localStorage.setItem(GEMINI_API_KEY, key);
                if (currentUser) {
                    await saveApiKeyToCloud(key);
                }
                apiKeyStatus.textContent = "API Key saved successfully!";
                apiKeyStatus.className = "text-sm text-green-600";
                apiKeyInput.value = '';
                apiKeyInput.placeholder = "••••••••••••••••••••••••••••••";
            } else {
                localStorage.removeItem(GEMINI_API_KEY);
                if (currentUser) {
                    await saveApiKeyToCloud(null);
                }
                apiKeyStatus.textContent = "API Key removed.";
                apiKeyStatus.className = "text-sm text-yellow-600";
                apiKeyInput.placeholder = "Enter your Gemini API Key";
            }
        });

        saveTargetsButton.addEventListener('click', () => {
            saveTargets();
            // Clear weight analysis cache as target has changed
            localStorage.removeItem(WEIGHT_ANALYSIS_KEY);
            localStorage.removeItem(FASTING_ANALYSIS_KEY);
            renderAll();
        });

        // Authentication event listeners
        signInButton.addEventListener('click', signInWithGoogle);
        signOutButton.addEventListener('click', signOutUser);
        
        // Dialog event listeners
        syncDialogCancel.addEventListener('click', hideSyncDialog);
        syncDialogReplace.addEventListener('click', replaceLocalWithCloud);

    </script>
</div>
</html>